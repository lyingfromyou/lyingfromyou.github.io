{"pages":[],"posts":[{"title":"","text":"Test","link":"/2021/05/27/Home/"},{"title":"JVM (Java Virtual Machine)(1)","text":"什么是 JVM? (它能干什么？达成了什么目的？) 将字节码转换成机器码并运行 内存管理 运行时数据区 方法区 (所有线程共享) 用来存储 类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据 java8 之前使用 永久代(PermGen) 来实现方法区, 8 之后使用本地内存中实现的**元空间(MetaSpace)**来代替 8 之前在程序启动时需要手动设置空间大小且无法动态扩容, 8 之后不需要手动设置, 在程序运行时会自动扩容, 扩容取决于操作系统内存大小限制 字符串常量在 1.8 之后存在堆中 堆 (所有线程共享) 虚拟机所管理的内存中最大的一块, 此内存区域的唯一目的就是存放对象实例 堆是垃圾回收器管理的内存区域, 也被称为 GC堆, 堆内存分代模型跟 GC 有关 分代模型 年轻代和老年代的默认比例为 1 : 2 年轻代(1) Eden(8) -&gt; 存储新创建的对象 s0(1) -&gt; 存储经过 YGC 还存在的对象 s1(1) -&gt; 存储经过 YGC 还存在的对象 第一次 YGC 时, 扫描 eden 区的对象, 将存活对象复制到 s0, 第二次回收时, 扫描 eden 和 s0 区的对象, 将存活对象复制到 s1, 第三次扫描 eden 和 s1, 将存活对象复制到 s0, 循环往复 老年代(2) 存储经过多次 YGC 的对象, 或大对象 调整堆大小 -Xmx 最大堆 -Xms 最小堆 程序技术器 (线程私有) 指向当前线程正在执行的字节码指令的地址、行号 CPU 在线程之间切换，需要标记当前线程执行到哪一步了 虚拟机栈 (线程私有) 描述的是方法在运行时的线程内存模型, 每个方法被执行的时候, 虚拟机都会同步创建一个栈帧, 用来存储 局部变量表、操作数栈、动态链接、方法出口 等信息 局部变量表 存储方法参数和局部变量 操作数栈 用来做方法的运算 动态链接 将符号引用转为直接引用 方法出口 方法返回地址 本地方法栈 (线程私有) 同虚拟机栈(native 方法) JVM 调优实际上就是为了让程序尽可能少的 FullGC","link":"/2021/05/27/JVM(%E4%B8%80)/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/05/27/hello-world/"}],"tags":[{"name":"test","slug":"test","link":"/tags/test/"}],"categories":[{"name":"MAX","slug":"MAX","link":"/categories/MAX/"},{"name":"JVM","slug":"MAX/JVM","link":"/categories/MAX/JVM/"},{"name":"test","slug":"MAX/test","link":"/categories/MAX/test/"}]}