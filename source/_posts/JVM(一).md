---
title: JVM (Java Virtual Machine)(1)
---


### 什么是 JVM? (它能干什么？达成了什么目的？)

1. 将字节码转换成机器码并运行

2. 内存管理

### 运行时数据区

![](https://gitee.com/Lyingfromyou/blog_img/raw/master/img/JVM运行时数据区.png)

- **方法区 (所有线程共享)**

  1. 用来存储 **类型信息、常量、静态变量、即时编译器编译后的代码缓存**等数据
  2. java8 之前使用 **永久代(PermGen)** 来实现方法区, 8 之后使用本地内存中实现的**元空间(MetaSpace)**来代替
  3. 8 之前在程序启动时需要手动设置空间大小且无法动态扩容, 8 之后不需要手动设置, 在程序运行时会自动扩容, 扩容取决于操作系统内存大小限制

  > 字符串常量在 1.8 之后存在堆中

- **堆 (所有线程共享)**

  1. 虚拟机所管理的内存中最大的一块, 此内存区域的唯一目的就是存放对象实例

  2. 堆是垃圾回收器管理的内存区域, 也被称为 GC堆, 堆内存分代模型跟 GC 有关

  3. 分代模型

     - 年轻代和老年代的默认比例为 1 : 2

       - 年轻代(1)

         - Eden(8) -> 存储新创建的对象

         - s0(1) -> 存储经过 YGC 还存在的对象

         - s1(1) -> 存储经过 YGC 还存在的对象

           > 第一次 YGC 时, 扫描 eden 区的对象, 将存活对象复制到 s0, 第二次回收时, 扫描 eden 和 s0 区的对象, 将存活对象复制到 s1, 第三次扫描 eden 和 s1, 将存活对象复制到 s0, 循环往复

       - 老年代(2)

         - 存储经过多次 YGC 的对象, 或大对象

  4. 调整堆大小

     - -Xmx 最大堆
     - -Xms 最小堆

  

- **程序技术器 (线程私有)**

  - 指向当前线程正在执行的字节码指令的地址、行号

  > CPU 在线程之间切换，需要标记当前线程执行到哪一步了

- **虚拟机栈 (线程私有)**

  描述的是方法在运行时的线程内存模型, 每个方法被执行的时候, 虚拟机都会同步创建一个栈帧, 用来存储 **局部变量表、操作数栈、动态链接、方法出口** 等信息

  - 局部变量表
    - 存储方法参数和局部变量
  - 操作数栈
    - 用来做方法的运算
  - 动态链接
    - 将符号引用转为直接引用
  - 方法出口
    - 方法返回地址

- **本地方法栈 (线程私有)**

  - 同虚拟机栈(native 方法)

> #### **JVM 调优实际上就是为了让程序尽可能少的 FullGC**



> test